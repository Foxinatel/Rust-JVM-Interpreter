use crate::helpers::{get_u8, get_i8, get_i16, get_i32, get_u16};

#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum Instructions {
  nop,
  aconst_null,
  iconst{value: i32},
  lconst{value: i64},
  fconst{value: f32},
  dconst{value: f64},
  bipush{byte: i8},
  sipush{short: i16},
  ldc{index: u8},
  ldc_w{index: u16},
  ldc2_w{index: u16},
  iload{index: u8},
  lload{index: u8},
  fload{index: u8},
  dload{index: u8},
  aload{index: u8},
  iaload,
  laload,
  faload,
  daload,
  aaload,
  baload,
  caload,
  saload,
  istore{index: u8},
  lstore{index: u8},
  fstore{index: u8},
  dstore{index: u8},
  astore{index: u8},
  iastore,
  lastore,
  fastore,
  dastore,
  aastore,
  bastore,
  castore,
  sastore,
  pop,
  pop2,
  dup,
  dup_x1,
  dup_x2,
  dup2,
  dup2_x1,
  dup2_x2,
  swap,
  iadd,
  ladd,
  fadd,
  dadd,
  isub,
  lsub,
  fsub,
  dsub,
  imul,
  lmul,
  fmul,
  dmul,
  idiv,
  ldiv,
  fdiv,
  ddiv,
  irem,
  lrem,
  frem,
  drem,
  ineg,
  lneg,
  fneg,
  dneg,
  ishl,
  lshl,
  ishr,
  lshr,
  iushr,
  lushr,
  iand,
  land,
  ior,
  lor,
  ixor,
  lxor,
  iinc,
  i2l,
  i2f,
  i2d,
  l2i,
  l2f,
  l2d,
  f2i,
  f2l,
  f2d,
  d2i,
  d2l,
  d2f,
  i2b,
  i2c,
  i2s,
  lcmp,
  fcmpl,
  fcmpg,
  dcmpl,
  dcmpg,
  ifeq{offset: i16},
  ifne{offset: i16},
  iflt{offset: i16},
  ifge{offset: i16},
  ifgt{offset: i16},
  ifle{offset: i16},
  if_icmpeq{offset: i16},
  if_icmpne{offset: i16},
  if_icmplt{offset: i16},
  if_icmpge{offset: i16},
  if_icmpgt{offset: i16},
  if_icmple{offset: i16},
  if_acmpeq{offset: i16},
  if_acmpne{offset: i16},
  goto{offset: i16},
  jsr{offset: i16},
  ret{index: u8},
  tableswitch{default: i32, low: i32, high: i32, offsets: Vec<i32>},
  lookupswith{default: i32, npairs: i32, pairs: Vec<(i32, i32)>},
  ireturn,
  lreturn,
  freturn,
  dreturn,
  areturn,
  r#return,
  getstatic{index: u16},
  putstatic{index: u16},
  getfield{index: u16},
  putfield{index: u16},
  invokevirtual{index: u16},
  invokespecial{index: u16},
  invokestatic{index: u16},
  invokeinterface{index: u16, count: u8},
  invokedynamic{index: u16},
  new{index: u16},
  newarray{atype: u8},
  anewarray{index: u16},
  arraylength,
  athrow,
  checkcast{index: u16},
  instanceof{index: u16},
  monitorenter,
  monitorexit,
  wide1{opcode: u8, index_extension: u16},
  wide2{opcode: u8, index_extension: u16, constbytes: i16},
  multianewarray{index: u16, dimensions: u8},
  ifnull{offset: i16},
  ifnonnull{offset: i16},
  goto_w{offset: i32},
  jsr_w{offset: i32},
}

pub fn generate_instructions(code: &mut &[u8]) -> Vec<Instructions> {
  let mut instructions = Vec::new();
  loop {
    if code.is_empty() {return instructions;}
    let inst = get_u8(code);
    instructions.push(
      match inst {
        0 => Instructions::nop,
        1 => Instructions::aconst_null,
        (2..=8) => Instructions::iconst{value: inst as i32 - 3},
        (9..=10) => Instructions::lconst{value: inst as i64 - 9},
        (11..=13) => Instructions::fconst{value: inst as f32 - 11.0},
        (14..=15) => Instructions::dconst{value: inst as f64 - 14.0},
        16 => Instructions::bipush{ byte: get_i8(code)},
        17 => Instructions::sipush{ short: get_i16(code) },
        18 => Instructions::ldc{ index: get_u8(code) },
        19 => Instructions::ldc_w{ index: get_u16(code) },
        20 => Instructions::ldc2_w{ index: get_u16(code) },
        21 => Instructions::iload{ index: get_u8(code) },
        22 => Instructions::lload{ index: get_u8(code) },
        23 => Instructions::fload{ index: get_u8(code) },
        24 => Instructions::dload{ index: get_u8(code) },
        25 => Instructions::aload{ index: get_u8(code) },
        (26..=29) => Instructions::iload{ index: inst-26 },
        (30..=33) => Instructions::lload{ index: inst-30 },
        (34..=37) => Instructions::fload{ index: inst-34 },
        (38..=41) => Instructions::dload{ index: inst-38 },
        (42..=45) => Instructions::aload{ index: inst-42 },
        46 => Instructions::iaload,
        47 => Instructions::laload,
        48 => Instructions::faload,
        49 => Instructions::daload,
        50 => Instructions::aaload,
        51 => Instructions::baload,
        52 => Instructions::caload,
        53 => Instructions::saload,
        54 => Instructions::istore{ index: get_u8(code) },
        55 => Instructions::lstore{ index: get_u8(code) },
        56 => Instructions::fstore{ index: get_u8(code) },
        57 => Instructions::dstore{ index: get_u8(code) },
        58 => Instructions::astore{ index: get_u8(code) },
        (59..=62) => Instructions::istore{ index: inst-59 },
        (63..=66) => Instructions::lstore{ index: inst-63 },
        (67..=70) => Instructions::fstore{ index: inst-67 },
        (71..=74) => Instructions::dstore{ index: inst-71 },
        (75..=78) => Instructions::astore{ index: inst-75 },
        79 => Instructions::iastore,
        80 => Instructions::lastore,
        81 => Instructions::fastore,
        82 => Instructions::dastore,
        83 => Instructions::aastore,
        84 => Instructions::bastore,
        85 => Instructions::castore,
        86 => Instructions::sastore,
        87 => Instructions::pop,
        88 => Instructions::pop2,
        89 => Instructions::dup,
        90 => Instructions::dup_x1,
        91 => Instructions::dup_x2,
        92 => Instructions::dup2,
        93 => Instructions::dup2_x1,
        94 => Instructions::dup2_x2,
        95 => Instructions::swap,
        96 => Instructions::iadd,
        97 => Instructions::ladd,
        98 => Instructions::fadd,
        99 => Instructions::dadd,
        100 => Instructions::isub,
        101 => Instructions::lsub,
        102 => Instructions::fsub,
        103 => Instructions::dsub,
        104 => Instructions::imul,
        105 => Instructions::lmul,
        106 => Instructions::fmul,
        107 => Instructions::dmul,
        108 => Instructions::idiv,
        109 => Instructions::ldiv,
        110 => Instructions::fdiv,
        111 => Instructions::ddiv,
        112 => Instructions::irem,
        113 => Instructions::lrem,
        114 => Instructions::frem,
        115 => Instructions::drem,
        116 => Instructions::ineg,
        117 => Instructions::lneg,
        118 => Instructions::fneg,
        119 => Instructions::dneg,
        120 => Instructions::ishl,
        121 => Instructions::lshl,
        122 => Instructions::ishr,
        123 => Instructions::lshr,
        124 => Instructions::iushr,
        125 => Instructions::lushr,
        126 => Instructions::iand,
        127 => Instructions::land,
        128 => Instructions::ior,
        129 => Instructions::lor,
        130 => Instructions::ixor,
        131 => Instructions::lxor,
        132 => Instructions::iinc,
        133 => Instructions::i2l,
        134 => Instructions::i2f,
        135 => Instructions::i2d,
        136 => Instructions::l2i,
        137 => Instructions::l2f,
        138 => Instructions::l2d,
        139 => Instructions::f2i,
        140 => Instructions::f2l,
        141 => Instructions::f2d,
        142 => Instructions::d2i,
        143 => Instructions::d2l,
        144 => Instructions::d2f,
        145 => Instructions::i2b,
        146 => Instructions::i2c,
        147 => Instructions::i2s,
        148 => Instructions::lcmp,
        149 => Instructions::fcmpl,
        150 => Instructions::fcmpg,
        151 => Instructions::dcmpl,
        152 => Instructions::dcmpg,
        153 => Instructions::ifeq{ offset: get_i16(code) },
        154 => Instructions::ifne{ offset: get_i16(code) },
        155 => Instructions::iflt{ offset: get_i16(code) },
        156 => Instructions::ifge{ offset: get_i16(code) },
        157 => Instructions::ifgt{ offset: get_i16(code) },
        158 => Instructions::ifle{ offset: get_i16(code) },
        159 => Instructions::if_icmpeq{ offset: get_i16(code) },
        160 => Instructions::if_icmpne{ offset: get_i16(code) },
        161 => Instructions::if_icmplt{ offset: get_i16(code) },
        162 => Instructions::if_icmpge{ offset: get_i16(code) },
        163 => Instructions::if_icmpgt{ offset: get_i16(code) },
        164 => Instructions::if_icmple{ offset: get_i16(code) },
        165 => Instructions::if_acmpeq{ offset: get_i16(code) },
        166 => Instructions::if_acmpne{ offset: get_i16(code) },
        167 => Instructions::goto{ offset: get_i16(code) },
        168 => Instructions::jsr{ offset: get_i16(code)  },
        169 => Instructions::ret{ index: get_u8(code) },
        170 => {
          let default = get_i32(code);
          let low = get_i32(code);
          let high = get_i32(code);
          let offsets: Vec<i32> = (0..high-low+1).map(|_|
            get_i32(code)
          ).collect();
          Instructions::tableswitch{ default, low, high, offsets }
        },
        171 => {
          let default = get_i32(code);
          let npairs = get_i32(code);
          let pairs: Vec<(i32,i32)> = (0..npairs).map(|_|
            (get_i32(code), get_i32(code))
          ).collect();
          Instructions::lookupswith{ default, npairs, pairs }
        },
        172 => Instructions::ireturn,
        173 => Instructions::lreturn,
        174 => Instructions::freturn,
        175 => Instructions::dreturn,
        176 => Instructions::areturn,
        177 => Instructions::r#return,
        178 => Instructions::getstatic{ index: get_u16(code) },
        179 => Instructions::putstatic{ index: get_u16(code) },
        180 => Instructions::getfield{ index: get_u16(code) },
        181 => Instructions::putfield{ index: get_u16(code) },
        182 => Instructions::invokevirtual{ index: get_u16(code) },
        183 => Instructions::invokespecial{ index: get_u16(code) },
        184 => Instructions::invokestatic{ index: get_u16(code) },
        185 =>  {
          let index = get_u16(code);
          let count = get_u8(code);
          assert_eq!(get_u8(code), 0, "Final byte of invokestatic was non-zero");
          Instructions::invokeinterface{ index, count }
        },
        186 => {
          let index = get_u16(code);
          assert_eq!(get_u16(code), 0, "Final bytes of invokedynamic was non-zero");
          Instructions::invokedynamic{ index }
        },
        187 => Instructions::new{ index: get_u16(code) },
        188 => Instructions::newarray{ atype: get_u8(code) },
        189 => Instructions::anewarray{ index: get_u16(code) },
        190 => Instructions::arraylength,
        191 => Instructions::athrow,
        192 => Instructions::checkcast{ index: get_u16(code) },
        193 => Instructions::instanceof{ index: get_u16(code) },
        194 => Instructions::monitorenter,
        195 => Instructions::monitorexit,
        196 => {
          let opcode = get_u8(code);
          match opcode {
            (21..=25) | (54..=58) | 169 => Instructions::wide1 { opcode, index_extension: get_u16(code) },
            132 => Instructions::wide2 { opcode, index_extension: get_u16(code), constbytes: get_i16(code) },
            _ => panic!("Attempted to perform 'wide' on invalid opcode")
          }
        }
        197 => Instructions::multianewarray{ index: get_u16(code), dimensions: get_u8(code) },
        198 => Instructions::ifnull{ offset: get_i16(code) },
        199 => Instructions::ifnonnull{ offset: get_i16(code) },
        200 => Instructions::goto_w{ offset: get_i32(code) },
        201 => Instructions::jsr_w{ offset: get_i32(code) },
        (202..) => panic!("Instruction not yet implemented")
      }
    );
  }
}